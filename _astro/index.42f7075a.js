function It(n,t){for(var e=0;e<t.length;e++){const r=t[e];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in n)){const o=Object.getOwnPropertyDescriptor(r,i);o&&Object.defineProperty(n,i,o.get?o:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}var U=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function xt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var X={},I={},B={},v={};Object.defineProperty(v,"__esModule",{value:!0});v.defaultMinorOrdering=v.ordering=void 0;v.ordering={natural:n=>[...n],reverse:n=>[...n].reverse(),half_shift:n=>[...n.slice(n.length/2),...n.slice(0,n.length/2)],reverse_half_shift:n=>[...n.slice(0,n.length/2).reverse(),...n.slice(n.length/2).reverse()],pair_flip:n=>{const t=[];for(let e=0;e<n.length;e+=2)t.push(n[e+1],n[e]);return t},inner_outer:n=>{if(n.length===2)return n;const t=n.length/4,e=[n.slice(t,2*t),n.slice(2*t,3*t)],r=[n.slice(0,t),n.slice(3*t,4*t)],i={inner(u){return[u[0].pop(),u[1].shift()]},outer(u){return[u[0].shift(),u[1].pop()]}},o=[];function a(u,d){u[0].length>0&&u[1].length>0&&o.push(...i[d](u))}for(let u=0;u<t/2;u++)a(r,"outer"),a(e,"inner"),a(r,"inner"),a(e,"outer");return o},"groups.effort_balanced":(n,t)=>{const e=[];let r=0,i=0;for(;e.length<n.length;)e.push(n[r]),r+=t,r>=n.length&&(r=++i);return e},"groups.seed_optimized":(n,t)=>{const e=Array.from(Array(t),r=>[]);for(let r=0;r<n.length/t;r++)if(r%2===0)for(let i=0;i<t;i++)e[i].push(n[r*t+i]);else for(let i=0;i<t;i++)e[t-i-1].push(n[r*t+i]);return e.flat()},"groups.bracket_optimized":()=>{throw Error("Not implemented.")}};v.defaultMinorOrdering={4:["natural","reverse"],8:["natural","reverse","natural"],16:["natural","reverse_half_shift","reverse","natural"],32:["natural","reverse","half_shift","natural","natural"],64:["natural","reverse","half_shift","reverse","natural","natural"],128:["natural","reverse","half_shift","pair_flip","pair_flip","pair_flip","natural"]};var s={},N={},nt={};Object.defineProperty(nt,"__esModule",{value:!0});var rt={};Object.defineProperty(rt,"__esModule",{value:!0});var it={};Object.defineProperty(it,"__esModule",{value:!0});var ot={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.Status=void 0,function(t){t[t.Locked=0]="Locked",t[t.Waiting=1]="Waiting",t[t.Ready=2]="Ready",t[t.Running=3]="Running",t[t.Completed=4]="Completed",t[t.Archived=5]="Archived"}(n.Status||(n.Status={}))})(ot);(function(n){var t=U&&U.__createBinding||(Object.create?function(r,i,o,a){a===void 0&&(a=o);var u=Object.getOwnPropertyDescriptor(i,o);(!u||("get"in u?!i.__esModule:u.writable||u.configurable))&&(u={enumerable:!0,get:function(){return i[o]}}),Object.defineProperty(r,a,u)}:function(r,i,o,a){a===void 0&&(a=o),r[a]=i[o]}),e=U&&U.__exportStar||function(r,i){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(i,o)&&t(i,r,o)};Object.defineProperty(n,"__esModule",{value:!0}),e(nt,n),e(rt,n),e(it,n),e(ot,n)})(N);Object.defineProperty(s,"__esModule",{value:!0});s.getNextSideLoserBracket=s.getNextSide=s.findParticipant=s.getGrandFinalDecisiveMatch=s.makeFinalStandings=s.getLosers=s.getOriginPosition=s.getOpponentId=s.resetMatchResults=s.setMatchResults=s.getMatchStatus=s.hasBye=s.isMatchParticipantLocked=s.isMatchUpdateLocked=s.isMatchByeCompleted=s.isMatchWinCompleted=s.isMatchDrawCompleted=s.isMatchResultCompleted=s.isMatchForfeitCompleted=s.isMatchCompleted=s.isMatchStarted=s.getOtherSide=s.getSide=s.findPosition=s.getMatchResult=s.byeLoser=s.byeWinnerToGrandFinal=s.byeWinner=s.getLoser=s.getWinner=s.toResultWithPosition=s.toResult=s.convertTBDtoBYE=s.ensureNotTied=s.ensureValidSize=s.fixSeeding=s.ensureEquallySized=s.ensureNoDuplicates=s.ensureEvenSized=s.makePairs=s.setArraySize=s.normalizeParticipant=s.makeNormalizedIdMapping=s.normalizeIds=s.balanceByes=s.makeGroups=s.assertRoundRobin=s.makeRoundRobinDistribution=s.makeRoundRobinMatches=s.splitByParity=void 0;s.getMatchLocation=s.isFinalGroup=s.isLoserBracket=s.isWinnerBracket=s.ensureNotRoundRobin=s.isRoundRobin=s.minScoreToWinBestOfX=s.getNearestPowerOfTwo=s.getDiagonalMatchNumber=s.getLowerBracketRoundCount=s.getLoserOrdering=s.getLoserRoundLoserCount=s.getLoserRoundMatchCount=s.findLoserMatchNumber=s.isDoubleEliminationNecessary=s.getRoundPairCount=s.getUpperBracketRoundCount=s.isOrderingSupportedLoserBracket=s.isOrderingSupportedUpperBracket=s.ensureOrderingSupported=s.getSeedCount=s.getSeeds=s.getChildGamesResults=s.getUpdatedMatchResults=s.getParentMatchResults=s.setParentMatchCompleted=s.transitionToMinor=s.transitionToMajor=s.uniqueBy=s.getNonNull=s.sortSeeding=s.convertSlotsToSeeding=s.convertMatchesToSeeding=s.mapParticipantsToDatabase=s.mapParticipantsIdsToDatabase=s.mapParticipantsNamesToDatabase=s.extractParticipantsFromSeeding=s.isCustomSeeding=s.isSeedingWithIds=s.setForfeits=s.setResults=s.setCompleted=s.setScores=s.invertOpponents=s.handleOpponentsInversion=s.resetNextOpponent=s.setNextOpponent=void 0;const M=N,st=v;function At(n){return{even:n.filter((t,e)=>e%2===0),odd:n.filter((t,e)=>e%2===1)}}s.splitByParity=At;function $t(n,t="simple"){const e=at(n);if(t==="simple")return e;const r=e.map(i=>[...i].reverse()).reverse();return[...e,...r]}s.makeRoundRobinMatches=$t;function at(n){const t=n.length,e=t%2===0?t:t+1,r=e-1,i=e/2,o=[];for(let a=0;a<r;a++){const u=[];for(let d=0;d<i;d++){if(d===0&&t%2===1)continue;const c=[(a-d-1+e)%(e-1),d===0?e-1:(a+d)%(e-1)];u.push([n[c[0]],n[c[1]]])}o.push(u)}return o}s.makeRoundRobinDistribution=at;function qt(n,t){const e=n.length,r=Math.floor(e/2),i=e%2===0?e-1:e;if(t.length!==i)throw Error("Round count is wrong");if(!t.every(a=>a.length===r))throw Error("Not every round has the good number of matches");const o=Object.fromEntries(n.map(a=>[a,new Set]));for(const a of t){const u=new Set;for(const d of a){if(d.length!==2)throw Error("One match is not a pair");if(u.has(d[0])||(u.add(d[0]),u.has(d[1])))throw Error("This team is already playing");if(u.add(d[1]),o[d[0]].has(d[1])||(o[d[0]].add(d[1]),o[d[1]].has(d[0])))throw Error("The team has already matched this team");o[d[1]].add(d[0])}}}s.assertRoundRobin=qt;function Yt(n,t){const e=Math.ceil(n.length/t),r=[];for(let i=0;i<n.length;i++)i%e===0&&r.push([]),r[r.length-1].push(n[i]);return r}s.makeGroups=Yt;function Vt(n,t){if(n=n.filter(u=>u!==null),t=t||Gt(n.length),n.length<t/2){const u=n.flatMap(d=>[d,null]);return j(u,t,null)}const e=n.length,r=t-e,i=n.slice(0,e-r).filter((u,d)=>d%2===0).map((u,d)=>[n[2*d],n[2*d+1]]),o=n.slice(e-r,e).map(u=>[u,null]),a=[...i.flat(),...o.flat()];return j(a,t,null)}s.balanceByes=Vt;function Xt(n){const t={participant:S(n.participant),stage:S(n.stage),group:S(n.group),round:S(n.round),match:S(n.match),match_game:S(n.match_game)};return{participant:n.participant.map(e=>({...e,id:t.participant[e.id]})),stage:n.stage.map(e=>({...e,id:t.stage[e.id]})),group:n.group.map(e=>({...e,id:t.group[e.id],stage_id:t.stage[e.stage_id]})),round:n.round.map(e=>({...e,id:t.round[e.id],stage_id:t.stage[e.stage_id],group_id:t.group[e.group_id]})),match:n.match.map(e=>({...e,id:t.match[e.id],stage_id:t.stage[e.stage_id],group_id:t.group[e.group_id],round_id:t.round[e.round_id],opponent1:P(e.opponent1,t.participant),opponent2:P(e.opponent2,t.participant)})),match_game:n.match_game.map(e=>({...e,id:t.match_game[e.id],stage_id:t.stage[e.stage_id],parent_id:t.match[e.parent_id],opponent1:P(e.opponent1,t.participant),opponent2:P(e.opponent2,t.participant)}))}}s.normalizeIds=Xt;function S(n){let t=0;return n.reduce((e,r)=>({...e,[r.id]:t++}),{})}s.makeNormalizedIdMapping=S;function P(n,t){return n===null?null:{...n,id:n.id!==null?t[n.id]:null}}s.normalizeParticipant=P;function j(n,t,e){return Array.from(Array(t),(r,i)=>n[i]||e)}s.setArraySize=j;function Jt(n){return n.map((t,e)=>e%2===0?[n[e],n[e+1]]:[]).filter(t=>t.length===2)}s.makePairs=Jt;function Qt(n){if(n.length%2===1)throw Error("Array size must be even.")}s.ensureEvenSized=Qt;function Ht(n){const t=Bt(n);if((typeof t[0]=="object"?t.filter((r,i)=>{const o=JSON.stringify(r);return i===t.findIndex(a=>JSON.stringify(a)===o)}):[...new Set(t)]).length<t.length)throw new Error("The seeding has a duplicate participant.")}s.ensureNoDuplicates=Ht;function Kt(n,t){if(n.length!==t.length)throw Error("Arrays' size must be equal.")}s.ensureEquallySized=Kt;function Zt(n,t){if(n.length>t)throw Error("The seeding has more participants than the size of the stage.");return n.length<t?j(n,t,null):n}s.fixSeeding=Zt;function te(n){if(n===0)throw Error("Impossible to create an empty stage. If you want an empty seeding, just set the size of the stage.");if(n<2)throw Error("Impossible to create a stage with less than 2 participants.");if(!Number.isInteger(Math.log2(n)))throw Error("The library only supports a participant count which is a power of two.")}s.ensureValidSize=te;function ee(n){if(n[0]===n[1])throw Error(`${n[0]} and ${n[1]} are tied. It cannot be.`)}s.ensureNotTied=ee;function ne(n){return n===null||n?.id===null?null:n}s.convertTBDtoBYE=ne;function re(n){return n&&{id:n.id}}s.toResult=re;function ie(n){return n&&{id:n.id,position:n.position}}s.toResultWithPosition=ie;function oe(n){const t=G(n);return t?n[t]:null}s.getWinner=oe;function ut(n){const t=G(n);return t?n[ct(t)]:null}s.getLoser=ut;function L(n){return n[0]===null&&n[1]===null?null:n[0]===null&&n[1]!==null?{id:n[1].id}:n[0]!==null&&n[1]===null?{id:n[0].id}:{id:null}}s.byeWinner=L;function se(n){const t=L(n);return t&&(t.position=1),t}s.byeWinnerToGrandFinal=se;function ae(n,t){return n[0]===null||n[1]===null?null:{id:null,position:t+1}}s.byeLoser=ae;function G(n){var t,e;if(!F(n)||J(n)||n.opponent1===null&&n.opponent2===null)return null;let r=null;if((((t=n.opponent1)===null||t===void 0?void 0:t.result)==="win"||n.opponent2===null||n.opponent2.forfeit)&&(r="opponent1"),((e=n.opponent2)===null||e===void 0?void 0:e.result)==="win"||n.opponent1===null||n.opponent1.forfeit){if(r!==null)throw Error("There are two winners.");r="opponent2"}return r}s.getMatchResult=G;function ue(n,t){var e,r;for(const i of n){if(((e=i.opponent1)===null||e===void 0?void 0:e.position)===t)return i.opponent1;if(((r=i.opponent2)===null||r===void 0?void 0:r.position)===t)return i.opponent2}return null}s.findPosition=ue;function dt(n){return n%2===1?"opponent1":"opponent2"}s.getSide=dt;function ct(n){return n==="opponent1"?"opponent2":"opponent1"}s.getOtherSide=ct;function lt(n){var t,e;return((t=n.opponent1)===null||t===void 0?void 0:t.score)!==void 0||((e=n.opponent2)===null||e===void 0?void 0:e.score)!==void 0}s.isMatchStarted=lt;function F(n){return ft(n)||gt(n)||ht(n)}s.isMatchCompleted=F;function gt(n){var t,e;return((t=n.opponent1)===null||t===void 0?void 0:t.forfeit)!==void 0||((e=n.opponent2)===null||e===void 0?void 0:e.forfeit)!==void 0}s.isMatchForfeitCompleted=gt;function ht(n){return J(n)||pt(n)}s.isMatchResultCompleted=ht;function J(n){var t,e;return((t=n.opponent1)===null||t===void 0?void 0:t.result)==="draw"&&((e=n.opponent2)===null||e===void 0?void 0:e.result)==="draw"}s.isMatchDrawCompleted=J;function pt(n){var t,e,r,i;return((t=n.opponent1)===null||t===void 0?void 0:t.result)==="win"||((e=n.opponent2)===null||e===void 0?void 0:e.result)==="win"||((r=n.opponent1)===null||r===void 0?void 0:r.result)==="loss"||((i=n.opponent2)===null||i===void 0?void 0:i.result)==="loss"}s.isMatchWinCompleted=pt;function ft(n){var t,e;return n.opponent1===null&&((t=n.opponent2)===null||t===void 0?void 0:t.id)!==null||n.opponent2===null&&((e=n.opponent1)===null||e===void 0?void 0:e.id)!==null||n.opponent1===null&&n.opponent2===null}s.isMatchByeCompleted=ft;function de(n){return n.status===M.Status.Locked||n.status===M.Status.Waiting||n.status===M.Status.Archived}s.isMatchUpdateLocked=de;function ce(n){return n.status>=M.Status.Running}s.isMatchParticipantLocked=ce;function wt(n){return n.opponent1===null||n.opponent2===null}s.hasBye=wt;function Q(n){var t,e,r,i;const o=Array.isArray(n)?{opponent1:n[0],opponent2:n[1]}:n;return wt(o)||((t=o.opponent1)===null||t===void 0?void 0:t.id)===null&&((e=o.opponent2)===null||e===void 0?void 0:e.id)===null?M.Status.Locked:((r=o.opponent1)===null||r===void 0?void 0:r.id)===null||((i=o.opponent2)===null||i===void 0?void 0:i.id)===null?M.Status.Waiting:F(o)?M.Status.Completed:lt(o)?M.Status.Running:M.Status.Ready}s.getMatchStatus=Q;function le(n,t,e){const r=F(t),i=F(n);vt(n,t);const o=bt(n,t);return r&&i?(V(n,t,e),{statusChanged:!1,resultChanged:!0}):r&&!i?(V(n,t,e),{statusChanged:!0,resultChanged:!0}):!r&&i?(mt(n),{statusChanged:!0,resultChanged:!0}):{statusChanged:o,resultChanged:!1}}s.setMatchResults=le;function mt(n){n.opponent1&&(n.opponent1.forfeit=void 0,n.opponent1.result=void 0),n.opponent2&&(n.opponent2.forfeit=void 0,n.opponent2.result=void 0),n.status=Q(n)}s.resetMatchResults=mt;function _t(n,t){const e=n[t];return e&&e.id}s.getOpponentId=_t;function ge(n,t){var e;const r=(e=n[t])===null||e===void 0?void 0:e.position;if(r===void 0)throw Error("Position is undefined.");return r}s.getOriginPosition=ge;function he(n,t){const e=[];let r=null,i=-1;for(const o of t){o.round_id!==r&&(r=o.round_id,i++,e[i]=[]);const a=ut(o);a!==null&&e[i].push(Mt(n,a))}return e}s.getLosers=he;function pe(n){const t=[];let e=1;for(const r of n){for(const i of r)t.push({id:i.id,name:i.name,rank:e});e++}return t}s.makeFinalStandings=pe;function fe(n,t){if(n==="simple")return t[0];if(n==="double")return G(t[0])==="opponent2"?t[1]:t[0];throw Error("The Grand Final is disabled.")}s.getGrandFinalDecisiveMatch=fe;function Mt(n,t){const e=n.find(r=>r.id===t?.id);if(!e)throw Error("Participant not found.");return e}s.findParticipant=Mt;function we(n,t,e,r){return r==="loser_bracket"&&t%2===1||r==="loser_bracket"&&t===e?"opponent2":dt(n)}s.getNextSide=we;function me(n,t,e){var r;return e>1||((r=t.opponent1)===null||r===void 0?void 0:r.position)===n?"opponent1":"opponent2"}s.getNextSideLoserBracket=me;function _e(n,t,e,r){var i;n[t]=e[r]&&{id:_t(e,r),position:(i=n[t])===null||i===void 0?void 0:i.position},n.status=Q(n)}s.setNextOpponent=_e;function Me(n,t){var e;n[t]=n[t]&&{id:null,position:(e=n[t])===null||e===void 0?void 0:e.position},n.status=M.Status.Locked}s.resetNextOpponent=Me;function vt(n,t){var e,r,i,o;const a=(e=t.opponent1)===null||e===void 0?void 0:e.id,u=(r=t.opponent2)===null||r===void 0?void 0:r.id,d=(i=n.opponent1)===null||i===void 0?void 0:i.id,c=(o=n.opponent2)===null||o===void 0?void 0:o.id;if(Number.isInteger(a)&&a!==d&&a!==c)throw Error("The given opponent1 ID does not exist in this match.");if(Number.isInteger(u)&&u!==d&&u!==c)throw Error("The given opponent2 ID does not exist in this match.");(Number.isInteger(a)&&a===c||Number.isInteger(u)&&u===d)&&yt(t)}s.handleOpponentsInversion=vt;function yt(n){[n.opponent1,n.opponent2]=[n.opponent2,n.opponent1]}s.invertOpponents=yt;function bt(n,t){var e,r,i,o;if(((e=t.opponent1)===null||e===void 0?void 0:e.score)===((r=n.opponent1)===null||r===void 0?void 0:r.score)&&((i=t.opponent2)===null||i===void 0?void 0:i.score)===((o=n.opponent2)===null||o===void 0?void 0:o.score))return!1;const a=n.status;return n.status=M.Status.Running,t.opponent1&&n.opponent1&&(n.opponent1.score=t.opponent1.score),t.opponent2&&n.opponent2&&(n.opponent2.score=t.opponent2.score),n.status!==a}s.setScores=bt;function V(n,t,e){n.status=M.Status.Completed,z(n,t,"win","loss",e),z(n,t,"loss","win",e),z(n,t,"draw","draw",e),n.opponent1&&!n.opponent2&&(n.opponent1.result="win"),!n.opponent1&&n.opponent2&&(n.opponent2.result="win"),Et(n,t)}s.setCompleted=V;function z(n,t,e,r,i){var o,a;if(t.opponent1&&t.opponent2){if(t.opponent1.result==="win"&&t.opponent2.result==="win")throw Error("There are two winners.");if(t.opponent1.result==="loss"&&t.opponent2.result==="loss")throw Error("There are two losers.");if(!i&&t.opponent1.forfeit===!0&&t.opponent2.forfeit===!0)throw Error("There are two forfeits.")}((o=t.opponent1)===null||o===void 0?void 0:o.result)===e&&(n.opponent1?n.opponent1.result=e:n.opponent1={id:null,result:e},n.opponent2?n.opponent2.result=r:n.opponent2={id:null,result:r}),((a=t.opponent2)===null||a===void 0?void 0:a.result)===e&&(n.opponent2?n.opponent2.result=e:n.opponent2={id:null,result:e},n.opponent1?n.opponent1.result=r:n.opponent1={id:null,result:r})}s.setResults=z;function Et(n,t){var e,r,i,o;if(((e=t.opponent1)===null||e===void 0?void 0:e.forfeit)===!0&&((r=t.opponent2)===null||r===void 0?void 0:r.forfeit)===!0){n.opponent1&&(n.opponent1.forfeit=!0),n.opponent2&&(n.opponent2.forfeit=!0);return}((i=t.opponent1)===null||i===void 0?void 0:i.forfeit)===!0&&(n.opponent1&&(n.opponent1.forfeit=!0),n.opponent2?n.opponent2.result="win":n.opponent2={id:null,result:"win"}),((o=t.opponent2)===null||o===void 0?void 0:o.forfeit)===!0&&(n.opponent2&&(n.opponent2.forfeit=!0),n.opponent1?n.opponent1.result="win":n.opponent1={id:null,result:"win"})}s.setForfeits=Et;function ve(n){return n.some(t=>typeof t=="number")}s.isSeedingWithIds=ve;function Rt(n){return n.some(t=>typeof t!="number"&&typeof t!="string"&&t!==null&&t!==void 0)}s.isCustomSeeding=Rt;function ye(n,t){return Rt(t)?t.filter(i=>i!==null).map(i=>({...i,tournament_id:n,name:i.name})):t.filter(i=>i!==null).map(i=>({tournament_id:n,name:i}))}s.extractParticipantsFromSeeding=ye;function be(n,t,e){return H("name",n,t,e)}s.mapParticipantsNamesToDatabase=be;function Ee(n,t,e){return H("id",n,t,e)}s.mapParticipantsIdsToDatabase=Ee;function H(n,t,e,r){const i=t.map((o,a)=>{if(o===null)return null;if(typeof o=="string"||typeof o=="number"){const u=e.find(d=>d[n]===o);if(!u)throw Error(`Participant ${n} not found in database.`);return{id:u.id,position:a+1}}else{const u=e.find(d=>d[n]===o[n]);if(!u)throw Error(`Custom participant ${n} not found in database.`);return{id:u.id,position:a+1}}});if(!r)return i;if(r.length!==i.length)throw Error("Not enough seeds in at least one group of the manual ordering.");return r.map(o=>i[o-1])}s.mapParticipantsToDatabase=H;function Re(n){const t=[].concat(...n.map(e=>[e.opponent1,e.opponent2]));return St(t)}s.convertMatchesToSeeding=Re;function Se(n){return n.map(t=>t===null||t.id===null?null:t.id)}s.convertSlotsToSeeding=Se;function St(n){const t=n.filter(i=>i!==null);if(t.sort((i,o)=>i.position-o.position),t.length===n.length)return t;const e=Object.fromEntries(t.map(i=>[i.position-1,i]));return Array.from({length:n.length},(i,o)=>e[o]||null)}s.sortSeeding=St;function Bt(n){return n.filter(e=>e!==null)}s.getNonNull=Bt;function Be(n,t){const e=new Set;return n.filter(r=>{const i=t(r);return i?e.has(i)?!1:(e.add(i),!0):!0})}s.uniqueBy=Be;function Ce(n){const t=n.length/2,e=[];for(let r=0;r<t;r++){const i=r*2;e.push([L(n[i]),L(n[i+1])])}return e}s.transitionToMajor=Ce;function ke(n,t,e){const r=e?st.ordering[e](t):t,i=n.length,o=[];for(let a=0;a<i;a++){const u=a;o.push([r[u],L(n[u])])}return o}s.transitionToMinor=ke;function Oe(n,t,e){var r,i;if(((r=n.opponent1)===null||r===void 0?void 0:r.score)===void 0||((i=n.opponent2)===null||i===void 0?void 0:i.score)===void 0)throw Error("Either opponent1, opponent2 or their scores are falsy.");const o=Tt(t);if(n.opponent1.score>=o){n.opponent1.result="win";return}if(n.opponent2.score>=o){n.opponent2.result="win";return}if(n.opponent1.score===n.opponent2.score&&n.opponent1.score+n.opponent2.score>t-1){if(e){n.opponent1.result="draw",n.opponent2.result="draw";return}throw Error("Match games result in a tie for the parent match.")}}s.setParentMatchCompleted=Oe;function Pe(n,t){return{opponent1:{id:n.opponent1&&n.opponent1.id,score:t.opponent1},opponent2:{id:n.opponent2&&n.opponent2.id,score:t.opponent2}}}s.getParentMatchResults=Pe;function Le(n,t,e){return{...t,...n,...e?{opponent1:n.opponent1===null?null:{...t.opponent1,...n.opponent1},opponent2:n.opponent2===null?null:{...t.opponent2,...n.opponent2}}:{opponent1:n.opponent1===null?{id:null}:{...t.opponent1,...n.opponent1},opponent2:n.opponent2===null?{id:null}:{...t.opponent2,...n.opponent2}}}}s.getUpdatedMatchResults=Le;function Fe(n){const t={opponent1:0,opponent2:0};for(const e of n){const r=G(e);r==="opponent1"?t.opponent1++:r==="opponent2"&&t.opponent2++}return t}s.getChildGamesResults=Fe;function Ne(n,t,e,r){const i=Ct(n,t,e,r);return Array.from(Array(i),(o,a)=>a+1)}s.getSeeds=Ne;function Ct(n,t,e,r){return kt(n,t,e),t===1?r*2:r}s.getSeedCount=Ct;function kt(n,t,e){if(n&&!Pt(t,e)||!n&&!Ot(t))throw Error("This round does not support ordering.")}s.ensureOrderingSupported=kt;function Ot(n){return n===1}s.isOrderingSupportedUpperBracket=Ot;function Pt(n,t){return n===1||n%2===0&&n<t}s.isOrderingSupportedLoserBracket=Pt;function Lt(n){return Math.log2(n)}s.getUpperBracketRoundCount=Lt;function K(n){return Lt(n)-1}s.getRoundPairCount=K;function Ge(n){return n>2}s.isDoubleEliminationNecessary=Ge;function Te(n,t,e,r){const i=Nt(n,t),o=Array.from(Array(i),(d,c)=>c+1),u=(r?st.ordering[r](o):o).indexOf(e)+1;return t===1?Math.ceil(u/2):u}s.findLoserMatchNumber=Te;function Ft(n,t){const e=Math.ceil(t/2)-1,r=K(n);return Math.pow(2,r-e-1)}s.getLoserRoundMatchCount=Ft;function Nt(n,t){const e=Ft(n,t);return t===1?e*2:e}s.getLoserRoundLoserCount=Nt;function De(n,t){const e=1+Math.floor(t/2);return n[e]}s.getLoserOrdering=De;function Ue(n){return K(n)*2}s.getLowerBracketRoundCount=Ue;function We(n){return Math.ceil(n/2)}s.getDiagonalMatchNumber=We;function Gt(n){return Math.pow(2,Math.ceil(Math.log2(n)))}s.getNearestPowerOfTwo=Gt;function Tt(n){return(n+1)/2}s.minScoreToWinBestOfX=Tt;function Dt(n){return n.type==="round_robin"}s.isRoundRobin=Dt;function ze(n){if(Dt(n))throw Error("Impossible to update ordering in a round-robin stage.")}s.ensureNotRoundRobin=ze;function Ut(n,t){return n==="double_elimination"&&t===1}s.isWinnerBracket=Ut;function Wt(n,t){return n==="double_elimination"&&t===2}s.isLoserBracket=Wt;function zt(n,t){return n==="single_elimination"&&t===2||n==="double_elimination"&&t===3}s.isFinalGroup=zt;function je(n,t){return Ut(n,t)?"winner_bracket":Wt(n,t)?"loser_bracket":zt(n,t)?"final_group":"single_bracket"}s.getMatchLocation=je;Object.defineProperty(B,"__esModule",{value:!0});B.Create=B.create=void 0;const C=v,l=s;async function Ie(n){await new jt(this.storage,n).run()}B.create=Ie;class jt{constructor(t,e){if(this.storage=t,this.stage=e,this.stage.settings=this.stage.settings||{},this.seedOrdering=this.stage.settings.seedOrdering||[],this.updateMode=!1,this.enableByesInUpdate=!1,!this.stage.name)throw Error("You must provide a name for the stage.");if(!Number.isInteger(this.stage.tournamentId))throw Error("You must provide a tournament id for the stage.");e.type==="round_robin"&&(this.stage.settings.roundRobinMode=this.stage.settings.roundRobinMode||"simple"),e.type==="single_elimination"&&(this.stage.settings.consolationFinal=this.stage.settings.consolationFinal||!1),e.type==="double_elimination"&&(this.stage.settings.grandFinal=this.stage.settings.grandFinal||"none"),this.stage.settings.matchesChildCount=this.stage.settings.matchesChildCount||0}async run(){let t=-1;switch(this.stage.type){case"round_robin":t=await this.roundRobin();break;case"single_elimination":t=await this.singleElimination();break;case"double_elimination":t=await this.doubleElimination();break;default:throw Error("Unknown stage type.")}if(t===-1)throw Error("Something went wrong when creating the stage.");await this.ensureSeedOrdering(t)}setExisting(t,e){this.updateMode=!0,this.currentStageId=t,this.enableByesInUpdate=e}async roundRobin(){const t=await this.getRoundRobinGroups(),e=await this.createStage();for(let r=0;r<t.length;r++)await this.createRoundRobinGroup(e,r+1,t[r]);return e}async singleElimination(){var t,e;if(Array.isArray((t=this.stage.settings)===null||t===void 0?void 0:t.seedOrdering)&&((e=this.stage.settings)===null||e===void 0?void 0:e.seedOrdering.length)!==1)throw Error("You must specify one seed ordering method.");const r=await this.getSlots(),i=await this.createStage(),o=this.getStandardBracketFirstRoundOrdering(),a=C.ordering[o](r),{losers:u}=await this.createStandardBracket(i,1,a);return await this.createConsolationFinal(i,u),i}async doubleElimination(){var t;if(this.stage.settings&&Array.isArray(this.stage.settings.seedOrdering)&&this.stage.settings.seedOrdering.length<1)throw Error("You must specify at least one seed ordering method.");const e=await this.getSlots(),r=await this.createStage(),i=this.getStandardBracketFirstRoundOrdering(),o=C.ordering[i](e);return!((t=this.stage.settings)===null||t===void 0)&&t.skipFirstRound?this.createDoubleEliminationSkipFirstRound(r,o):this.createDoubleElimination(r,o)}async createDoubleEliminationSkipFirstRound(t,e){var r;const{even:i,odd:o}=l.splitByParity(e),{losers:a,winner:u}=await this.createStandardBracket(t,1,i);if(l.isDoubleEliminationNecessary((r=this.stage.settings)===null||r===void 0?void 0:r.size)){const d=await this.createLowerBracket(t,2,[o,...a]);await this.createGrandFinal(t,u,d)}return t}async createDoubleElimination(t,e){var r;const{losers:i,winner:o}=await this.createStandardBracket(t,1,e);if(l.isDoubleEliminationNecessary((r=this.stage.settings)===null||r===void 0?void 0:r.size)){const a=await this.createLowerBracket(t,2,i);await this.createGrandFinal(t,o,a)}return t}async createRoundRobinGroup(t,e,r){var i;const o=await this.insertGroup({stage_id:t,number:e});if(o===-1)throw Error("Could not insert the group.");const a=l.makeRoundRobinMatches(r,(i=this.stage.settings)===null||i===void 0?void 0:i.roundRobinMode);for(let u=0;u<a.length;u++)await this.createRound(t,o,u+1,a[0].length,a[u])}async createStandardBracket(t,e,r){const i=l.getUpperBracketRoundCount(r.length),o=await this.insertGroup({stage_id:t,number:e});if(o===-1)throw Error("Could not insert the group.");let a=l.makePairs(r),u=1;const d=[];for(let c=i-1;c>=0;c--){const p=Math.pow(2,c);a=this.getCurrentDuels(a,p),d.push(a.map(l.byeLoser)),await this.createRound(t,o,u++,p,a)}return{losers:d,winner:l.byeWinner(a[0])}}async createLowerBracket(t,e,r){var i;const o=(i=this.stage.settings)===null||i===void 0?void 0:i.size,a=l.getRoundPairCount(o);let u=0;const d=this.getMajorOrdering(o),c=C.ordering[d](r[u++]),p=await this.insertGroup({stage_id:t,number:e});if(p===-1)throw Error("Could not insert the group.");let w=l.makePairs(c),m=1;for(let f=0;f<a;f++){const _=Math.pow(2,a-f-1);w=this.getCurrentDuels(w,_,!0),await this.createRound(t,p,m++,_,w);const b=this.getMinorOrdering(o,f,a);w=this.getCurrentDuels(w,_,!1,r[u++],b),await this.createRound(t,p,m++,_,w)}return l.byeWinnerToGrandFinal(w[0])}async createUniqueMatchBracket(t,e,r){const i=await this.insertGroup({stage_id:t,number:e});if(i===-1)throw Error("Could not insert the group.");for(let o=0;o<r.length;o++)await this.createRound(t,i,o+1,1,[r[o]])}async createRound(t,e,r,i,o){const a=this.getMatchesChildCount(),u=await this.insertRound({number:r,stage_id:t,group_id:e});if(u===-1)throw Error("Could not insert the round.");for(let d=0;d<i;d++)await this.createMatch(t,e,u,d+1,o[d],a)}async createMatch(t,e,r,i,o,a){const u=l.toResultWithPosition(o[0]),d=l.toResultWithPosition(o[1]);if(this.stage.type==="round_robin"&&u===null&&d===null)return;let c=null,p=l.getMatchStatus(o);if(this.updateMode){c=await this.storage.selectFirst("match",{round_id:r,number:i});const m=c?.child_count;if(a=m===void 0?a:m,c){const f=l.getMatchStatus(c);f>p&&(p=f)}}const w=await this.insertMatch({number:i,stage_id:t,group_id:e,round_id:r,child_count:a,status:p,opponent1:u,opponent2:d},c);if(w===-1)throw Error("Could not insert the match.");for(let m=0;m<a;m++)if(await this.insertMatchGame({number:m+1,stage_id:t,parent_id:w,status:p,opponent1:l.toResult(o[0]),opponent2:l.toResult(o[1])})===-1)throw Error("Could not insert the match game.")}getCurrentDuels(t,e,r,i,o){return(r===void 0||r)&&t.length===e?t:r===void 0||r?l.transitionToMajor(t):l.transitionToMinor(t,i,o)}async getSlots(t){var e,r;const i=((e=this.stage.settings)===null||e===void 0?void 0:e.size)||((r=this.stage.seeding)===null||r===void 0?void 0:r.length)||0;if(l.ensureValidSize(i),i&&!this.stage.seeding)return Array.from(Array(i),(o,a)=>({id:null,position:a+1}));if(!this.stage.seeding)throw Error("Either size or seeding must be given.");return this.stage.settings={...this.stage.settings,size:i},l.ensureNoDuplicates(this.stage.seeding),this.stage.seeding=l.fixSeeding(this.stage.seeding,i),this.stage.type!=="round_robin"&&this.stage.settings.balanceByes&&(this.stage.seeding=l.balanceByes(this.stage.seeding,this.stage.settings.size)),l.isSeedingWithIds(this.stage.seeding)?this.getSlotsUsingIds(this.stage.seeding,t):this.getSlotsUsingNames(this.stage.seeding,t)}async getSlotsUsingNames(t,e){const r=l.extractParticipantsFromSeeding(this.stage.tournamentId,t);if(!await this.registerParticipants(r))throw Error("Error registering the participants.");const i=await this.storage.select("participant",{tournament_id:this.stage.tournamentId});if(!i)throw Error("Error getting registered participant.");return l.mapParticipantsNamesToDatabase(t,i,e)}async getSlotsUsingIds(t,e){const r=await this.storage.select("participant",{tournament_id:this.stage.tournamentId});if(!r)throw Error("No available participants.");return l.mapParticipantsIdsToDatabase(t,r,e)}async getStageNumber(){const t=await this.storage.select("stage",{tournament_id:this.stage.tournamentId}),e=t?.map(i=>i.number);if(this.stage.number!==void 0){if(e?.includes(this.stage.number))throw Error("The given stage number already exists.");return this.stage.number}return e?.length?Math.max(...e)+1:1}getMatchesChildCount(){var t;return!((t=this.stage.settings)===null||t===void 0)&&t.matchesChildCount?this.stage.settings.matchesChildCount:0}getOrdering(t,e,r){var i;if(!(!((i=this.stage.settings)===null||i===void 0)&&i.seedOrdering))return this.seedOrdering.push(r),r;const o=this.stage.settings.seedOrdering[t];if(!o)return this.seedOrdering.push(r),r;if(e==="elimination"&&o.match(/^groups\./))throw Error("You must specify a seed ordering method without a 'groups' prefix");if(e==="groups"&&o!=="natural"&&!o.match(/^groups\./))throw Error("You must specify a seed ordering method with a 'groups' prefix");return o}async getRoundRobinGroups(){var t,e,r,i,o;if(((t=this.stage.settings)===null||t===void 0?void 0:t.groupCount)===void 0||!Number.isInteger(this.stage.settings.groupCount))throw Error("You must specify a group count for round-robin stages.");if(this.stage.settings.groupCount<=0)throw Error("You must provide a strictly positive group count.");if(!((e=this.stage.settings)===null||e===void 0)&&e.manualOrdering){if(((r=this.stage.settings)===null||r===void 0?void 0:r.manualOrdering.length)!==((i=this.stage.settings)===null||i===void 0?void 0:i.groupCount))throw Error("Group count in the manual ordering does not correspond to the given group count.");const c=(o=this.stage.settings)===null||o===void 0?void 0:o.manualOrdering.flat(),p=await this.getSlots(c);return l.makeGroups(p,this.stage.settings.groupCount)}if(Array.isArray(this.stage.settings.seedOrdering)&&this.stage.settings.seedOrdering.length!==1)throw Error("You must specify one seed ordering method.");const a=this.getRoundRobinOrdering(),u=await this.getSlots(),d=C.ordering[a](u,this.stage.settings.groupCount);return l.makeGroups(d,this.stage.settings.groupCount)}getRoundRobinOrdering(){return this.getOrdering(0,"groups","groups.effort_balanced")}getStandardBracketFirstRoundOrdering(){return this.getOrdering(0,"elimination","inner_outer")}getMajorOrdering(t){var e;return this.getOrdering(1,"elimination",((e=C.defaultMinorOrdering[t])===null||e===void 0?void 0:e[0])||"natural")}getMinorOrdering(t,e,r){var i;if(e!==r-1)return this.getOrdering(2+e,"elimination",((i=C.defaultMinorOrdering[t])===null||i===void 0?void 0:i[1+e])||"natural")}async insertStage(t){let e=null;return this.updateMode&&(e=await this.storage.select("stage",this.currentStageId)),e?e.id:this.storage.insert("stage",t)}async insertGroup(t){let e=null;return this.updateMode&&(e=await this.storage.selectFirst("group",{stage_id:t.stage_id,number:t.number})),e?e.id:this.storage.insert("group",t)}async insertRound(t){let e=null;return this.updateMode&&(e=await this.storage.selectFirst("round",{group_id:t.group_id,number:t.number})),e?e.id:this.storage.insert("round",t)}async insertMatch(t,e){if(!e)return this.storage.insert("match",t);const r=l.getUpdatedMatchResults(t,e,this.enableByesInUpdate);if(!await this.storage.update("match",e.id,r))throw Error("Could not update the match.");return e.id}async insertMatchGame(t){let e=null;if(this.updateMode&&(e=await this.storage.selectFirst("match_game",{parent_id:t.parent_id,number:t.number})),!e)return this.storage.insert("match_game",t);const r=l.getUpdatedMatchResults(t,e,this.enableByesInUpdate);if(!await this.storage.update("match_game",e.id,r))throw Error("Could not update the match game.");return e.id}async registerParticipants(t){const e=await this.storage.select("participant",{tournament_id:this.stage.tournamentId});if(!e||e.length===0)return this.storage.insert("participant",t);for(const r of t){if(e.some(o=>o.name===r.name))continue;if(await this.storage.insert("participant",r)===-1)return!1}return!0}async createStage(){const t=await this.getStageNumber(),e=await this.insertStage({tournament_id:this.stage.tournamentId,name:this.stage.name,type:this.stage.type,number:t,settings:this.stage.settings||{}});if(e===-1)throw Error("Could not insert the stage.");return e}async createConsolationFinal(t,e){var r;if(!(!((r=this.stage.settings)===null||r===void 0)&&r.consolationFinal))return;const i=e[e.length-2];await this.createUniqueMatchBracket(t,2,[i])}async createGrandFinal(t,e,r){var i;const o=(i=this.stage.settings)===null||i===void 0?void 0:i.grandFinal;if(o==="none")return;const a=[[e,r]];o==="double"&&a.push([{id:null},{id:null}]),await this.createUniqueMatchBracket(t,3,a)}async ensureSeedOrdering(t){var e,r;if(((r=(e=this.stage.settings)===null||e===void 0?void 0:e.seedOrdering)===null||r===void 0?void 0:r.length)===this.seedOrdering.length)return;const i=await this.storage.select("stage",t);if(!i)throw Error("Stage not found.");if(i.settings={...i.settings,seedOrdering:this.seedOrdering},!await this.storage.update("stage",t,i))throw Error("Could not update the stage.")}}B.Create=jt;var T={},k={};Object.defineProperty(k,"__esModule",{value:!0});k.BaseGetter=void 0;const y=s;class xe{constructor(t){this.storage=t}async getOrderedRounds(t){if(!t?.settings.size)throw Error("The stage has no size.");return t.type==="single_elimination"?this.getOrderedRoundsSingleElimination(t.id):this.getOrderedRoundsDoubleElimination(t.id)}async getOrderedRoundsSingleElimination(t){return[await this.getUpperBracketFirstRound(t)]}async getOrderedRoundsDoubleElimination(t){const e=await this.storage.select("round",{stage_id:t});if(!e)throw Error("Error getting rounds.");const r=await this.getLoserBracket(t);if(!r)throw Error("Loser bracket not found.");const i=e[0],o=e.filter(u=>u.group_id===r.id),a=o.filter(u=>y.isOrderingSupportedLoserBracket(u.number,o.length));return[i,...a]}async getRoundPositionalInfo(t){const e=await this.storage.select("round",t);if(!e)throw Error("Round not found.");const r=await this.storage.select("round",{group_id:e.group_id});if(!r)throw Error("Error getting rounds.");return{roundNumber:e.number,roundCount:r.length}}async getPreviousMatches(t,e,r,i){return e==="loser_bracket"?this.getPreviousMatchesLB(t,r,i):e==="final_group"?this.getPreviousMatchesFinal(t,i):i===1?[]:this.getMatchesBeforeMajorRound(t,i)}async getPreviousMatchesFinal(t,e){if(e>1)return[await this.findMatch(t.group_id,e-1,1)];const r=await this.getUpperBracket(t.stage_id),i=await this.getLastRound(r.id),o=await this.storage.selectFirst("match",{round_id:i.id,number:1});if(o===null)throw Error("Match not found.");return[o]}async getPreviousMatchesLB(t,e,r){if(e.settings.skipFirstRound&&r===1)return[];if(y.hasBye(t))return[];const i=await this.getUpperBracket(t.stage_id),o=Math.ceil((r+1)/2),a=e.settings.skipFirstRound?o-1:o;return r===1?this.getMatchesBeforeFirstRoundLB(t,i.id,a):r%2===0?this.getMatchesBeforeMinorRoundLB(t,i.id,r,a):this.getMatchesBeforeMajorRound(t,r)}async getMatchesBeforeMajorRound(t,e){return[await this.findMatch(t.group_id,e-1,t.number*2-1),await this.findMatch(t.group_id,e-1,t.number*2)]}async getMatchesBeforeFirstRoundLB(t,e,r){return[await this.findMatch(e,r,y.getOriginPosition(t,"opponent1")),await this.findMatch(e,r,y.getOriginPosition(t,"opponent2"))]}async getMatchesBeforeMinorRoundLB(t,e,r,i){const o=y.getOriginPosition(t,"opponent1");return[await this.findMatch(e,i,o),await this.findMatch(t.group_id,r-1,t.number)]}async getNextMatches(t,e,r,i,o){switch(e){case"single_bracket":return this.getNextMatchesUpperBracket(t,r.type,i,o);case"winner_bracket":return this.getNextMatchesWB(t,r,i,o);case"loser_bracket":return this.getNextMatchesLB(t,r.type,i,o);case"final_group":return this.getNextMatchesFinal(t,i,o);default:throw Error("Unknown bracket kind.")}}async getNextMatchesWB(t,e,r,i){const o=await this.getLoserBracket(t.stage_id);if(o===null)return[];const a=e.settings.skipFirstRound?r+1:r,u=a>1?(a-1)*2:1,d=e.settings.size,c=y.getLoserOrdering(e.settings.seedOrdering,u),p=y.findLoserMatchNumber(d,u,t.number,c);return[...await this.getNextMatchesUpperBracket(t,e.type,r,i),await this.findMatch(o.id,u,p)]}async getNextMatchesUpperBracket(t,e,r,i){return e==="single_elimination"?this.getNextMatchesUpperBracketSingleElimination(t,e,r,i):e==="double_elimination"&&r===i?[await this.getFirstMatchFinal(t,e)]:[await this.getDiagonalMatch(t.group_id,r,t.number)]}async getNextMatchesUpperBracketSingleElimination(t,e,r,i){if(r===i-1){const o=await this.getFirstMatchFinal(t,e);return[await this.getDiagonalMatch(t.group_id,r,t.number),...o?[o]:[]]}return r===i?[]:[await this.getDiagonalMatch(t.group_id,r,t.number)]}async getNextMatchesLB(t,e,r,i){if(r===i){const o=await this.getFirstMatchFinal(t,e);return o?[o]:[]}return r%2===1?this.getMatchAfterMajorRoundLB(t,r):this.getMatchAfterMinorRoundLB(t,r)}async getFirstMatchFinal(t,e){const r=await this.getFinalGroupId(t.stage_id,e);return r===null?null:this.findMatch(r,1,1)}async getNextMatchesFinal(t,e,r){return e===r?[]:[await this.findMatch(t.group_id,e+1,1)]}async getMatchAfterMajorRoundLB(t,e){return[await this.getParallelMatch(t.group_id,e,t.number)]}async getMatchAfterMinorRoundLB(t,e){return[await this.getDiagonalMatch(t.group_id,e,t.number)]}static getSeedingOrdering(t,e){return t==="round_robin"?e.getRoundRobinOrdering():e.getStandardBracketFirstRoundOrdering()}async getSeedingMatches(t,e){if(e==="round_robin")return this.storage.select("match",{stage_id:t});const r=await this.getUpperBracketFirstRound(t);return this.storage.select("match",{round_id:r.id})}async getUpperBracketFirstRound(t){const e=await this.storage.selectFirst("round",{stage_id:t,number:1});if(!e)throw Error("Round not found.");return e}async getLastRound(t){const e=await this.storage.selectLast("round",{group_id:t});if(!e)throw Error("Error getting rounds.");return e}async getFinalGroupId(t,e){const r=e==="single_elimination"?2:3,i=await this.storage.selectFirst("group",{stage_id:t,number:r});return i?i.id:null}async getUpperBracket(t){const e=await this.storage.selectFirst("group",{stage_id:t,number:1});if(!e)throw Error("Winner bracket not found.");return e}async getLoserBracket(t){return this.storage.selectFirst("group",{stage_id:t,number:2})}async getDiagonalMatch(t,e,r){return this.findMatch(t,e+1,y.getDiagonalMatchNumber(r))}async getParallelMatch(t,e,r){return this.findMatch(t,e+1,r)}async findMatch(t,e,r){const i=await this.storage.selectFirst("round",{group_id:t,number:e});if(!i)throw Error("Round not found.");const o=await this.storage.selectFirst("match",{round_id:i.id,number:r});if(!o)throw Error("Match not found.");return o}async findMatchGame(t){if(t.id!==void 0){const e=await this.storage.select("match_game",t.id);if(!e)throw Error("Match game not found.");return e}if(t.parent_id!==void 0&&t.number){const e=await this.storage.selectFirst("match_game",{parent_id:t.parent_id,number:t.number});if(!e)throw Error("Match game not found.");return e}throw Error("No match game id nor parent id and number given.")}}k.BaseGetter=xe;Object.defineProperty(T,"__esModule",{value:!0});T.Get=void 0;const Ae=k,h=s;class $e extends Ae.BaseGetter{async stageData(t){const e=await this.getStageSpecificData(t),r=await this.storage.select("participant",{tournament_id:e.stage.tournament_id});if(!r)throw Error("Error getting participants.");return{stage:[e.stage],group:e.groups,round:e.rounds,match:e.matches,match_game:e.matchGames,participant:r}}async tournamentData(t){const e=await this.storage.select("stage",{tournament_id:t});if(!e)throw Error("Error getting stages.");const r=await Promise.all(e.map(o=>this.getStageSpecificData(o.id))),i=await this.storage.select("participant",{tournament_id:t});if(!i)throw Error("Error getting participants.");return{stage:e,group:r.reduce((o,a)=>[...o,...a.groups],[]),round:r.reduce((o,a)=>[...o,...a.rounds],[]),match:r.reduce((o,a)=>[...o,...a.matches],[]),match_game:r.reduce((o,a)=>[...o,...a.matchGames],[]),participant:i}}async matchGames(t){const e=t.filter(i=>i.child_count>0),r=await Promise.all(e.map(i=>this.storage.select("match_game",{parent_id:i.id})));if(r.some(i=>i===null))throw Error("Error getting match games.");return h.getNonNull(r).flat()}async seeding(t){const e=await this.storage.select("stage",t);if(!e)throw Error("Stage not found.");return e.type==="round_robin"?this.roundRobinSeeding(e):this.eliminationSeeding(e)}async finalStandings(t){const e=await this.storage.select("stage",t);if(!e)throw Error("Stage not found.");switch(e.type){case"round_robin":throw Error("A round-robin stage does not have standings.");case"single_elimination":return this.singleEliminationStandings(t);case"double_elimination":return this.doubleEliminationStandings(t);default:throw Error("Unknown stage type.")}}async roundRobinSeeding(t){if(t.settings.size===void 0)throw Error("The size of the seeding is undefined.");const e=await this.storage.select("match",{stage_id:t.id});if(!e)throw Error("Error getting matches.");const r=h.convertMatchesToSeeding(e);if(r.length<t.settings.size){const a=t.settings.size-r.length;for(let u=0;u<a;u++)r.push(null)}const i=h.uniqueBy(r,a=>a&&a.position);return h.setArraySize(i,t.settings.size,null)}async eliminationSeeding(t){const e=await this.storage.selectFirst("round",{stage_id:t.id,number:1});if(!e)throw Error("Error getting the first round.");const r=await this.storage.select("match",{round_id:e.id});if(!r)throw Error("Error getting matches.");return h.convertMatchesToSeeding(r)}async singleEliminationStandings(t){var e;const r=[],{stage:i,group:o,match:a,participant:u}=await this.stageData(t),[d]=i,[c,p]=o,w=a.filter(f=>f.group_id===c.id).pop();if(!w)throw Error("Final not found.");r[0]=[h.findParticipant(u,h.getWinner(w))];const m=h.getLosers(u,a.filter(f=>f.group_id===c.id));if(r.push(...m.reverse()),!((e=d.settings)===null||e===void 0)&&e.consolationFinal){const f=a.filter(_=>_.group_id===p.id).pop();if(!f)throw Error("Consolation final not found.");r[2][0]=h.findParticipant(u,h.getWinner(f)),r[2][1]=h.findParticipant(u,h.getLoser(f))}return h.makeFinalStandings(r)}async doubleEliminationStandings(t){var e,r;const i=[],{stage:o,group:a,match:u,participant:d}=await this.stageData(t),[c]=o,[p,w,m]=a;if(((e=c.settings)===null||e===void 0?void 0:e.grandFinal)==="none"){const _=u.filter(O=>O.group_id===p.id).pop();if(!_)throw Error("WB final not found.");const b=u.filter(O=>O.group_id===w.id).pop();if(!b)throw Error("LB final not found.");i[0]=[h.findParticipant(d,h.getWinner(_))],i[1]=[h.findParticipant(d,h.getWinner(b))]}else{const _=u.filter(O=>O.group_id===m.id),b=h.getGrandFinalDecisiveMatch(((r=c.settings)===null||r===void 0?void 0:r.grandFinal)||"none",_);i[0]=[h.findParticipant(d,h.getWinner(b))],i[1]=[h.findParticipant(d,h.getLoser(b))]}const f=h.getLosers(d,u.filter(_=>_.group_id===w.id));return i.push(...f.reverse()),h.makeFinalStandings(i)}async getStageSpecificData(t){const e=await this.storage.select("stage",t);if(!e)throw Error("Stage not found.");const r=await this.storage.select("group",{stage_id:t});if(!r)throw Error("Error getting groups.");const i=await this.storage.select("round",{stage_id:t});if(!i)throw Error("Error getting rounds.");const o=await this.storage.select("match",{stage_id:t});if(!o)throw Error("Error getting matches.");const a=await this.matchGames(o);return{stage:e,groups:r,rounds:i,matches:o,matchGames:a}}}T.Get=$e;var x={},D={};Object.defineProperty(D,"__esModule",{value:!0});D.BaseUpdater=void 0;const W=N,qe=v,tt=B,et=k,Ye=T,g=s;class Z extends et.BaseGetter{async updateSeeding(t,e){const r=await this.storage.select("stage",t);if(!r)throw Error("Stage not found.");const i=new tt.Create(this.storage,{name:r.name,tournamentId:r.tournament_id,type:r.type,settings:r.settings,seeding:e||void 0});i.setExisting(t,!1);const o=et.BaseGetter.getSeedingOrdering(r.type,i),a=await i.getSlots(),u=await this.getSeedingMatches(r.id,r.type);if(!u)throw Error("Error getting matches associated to the seeding.");const d=qe.ordering[o](a);await Z.assertCanUpdateSeeding(u,d),await i.run()}async confirmCurrentSeeding(t){const e=await this.storage.select("stage",t);if(!e)throw Error("Stage not found.");const i=await new Ye.Get(this.storage).seeding(t),o=g.convertSlotsToSeeding(i.map(g.convertTBDtoBYE)),a=new tt.Create(this.storage,{name:e.name,tournamentId:e.tournament_id,type:e.type,settings:e.settings,seeding:o});a.setExisting(t,!0),await a.run()}async updateParentMatch(t,e){const r=await this.storage.select("match",t);if(!r)throw Error("Parent not found.");const i=await this.storage.select("match_game",{parent_id:t});if(!i)throw Error("No match games.");const o=g.getChildGamesResults(i),a=g.getParentMatchResults(r,o);g.setParentMatchCompleted(a,r.child_count,e),await this.updateMatch(r,a,!0)}static async assertCanUpdateSeeding(t,e){var r,i;let o=0;for(const a of t){const u=e[o++],d=e[o++];if(g.isMatchParticipantLocked(a)&&(((r=a.opponent1)===null||r===void 0?void 0:r.id)!==u?.id||((i=a.opponent2)===null||i===void 0?void 0:i.id)!==d?.id))throw Error("A match is locked.")}}async updateRelatedMatches(t,e,r){const{roundNumber:i,roundCount:o}=await this.getRoundPositionalInfo(t.round_id),a=await this.storage.select("stage",t.stage_id);if(!a)throw Error("Stage not found.");const u=await this.storage.select("group",t.group_id);if(!u)throw Error("Group not found.");const d=g.getMatchLocation(a.type,u.number);e&&await this.updatePrevious(t,d,a,i),r&&await this.updateNext(t,d,a,i,o)}async updateMatch(t,e,r){if(!r&&g.isMatchUpdateLocked(t))throw Error("The match is locked.");const i=await this.storage.select("stage",t.stage_id);if(!i)throw Error("Stage not found.");const o=g.isRoundRobin(i),{statusChanged:a,resultChanged:u}=g.setMatchResults(t,e,o);await this.applyMatchUpdate(t),!(!a&&!u)&&(g.isRoundRobin(i)||await this.updateRelatedMatches(t,a,u))}async updateMatchGame(t,e){if(g.isMatchUpdateLocked(t))throw Error("The match game is locked.");const r=await this.storage.select("stage",t.stage_id);if(!r)throw Error("Stage not found.");const i=g.isRoundRobin(r);if(g.setMatchResults(t,e,i),!await this.storage.update("match_game",t.id,t))throw Error("Could not update the match game.");await this.updateParentMatch(t.parent_id,i)}async applyMatchUpdate(t){if(!await this.storage.update("match",t.id,t))throw Error("Could not update the match.");if(t.child_count===0)return;const e={opponent1:g.toResult(t.opponent1),opponent2:g.toResult(t.opponent2)};if((t.status<=W.Status.Ready||t.status===W.Status.Archived)&&(e.status=t.status),!await this.storage.update("match_game",{parent_id:t.id},e))throw Error("Could not update the match game.")}async updatePrevious(t,e,r,i){const o=await this.getPreviousMatches(t,e,r,i);o.length!==0&&(t.status>=W.Status.Running?await this.archiveMatches(o):await this.resetMatchesStatus(o))}async archiveMatches(t){for(const e of t)e.status=W.Status.Archived,await this.applyMatchUpdate(e)}async resetMatchesStatus(t){for(const e of t)e.status=g.getMatchStatus(e),await this.applyMatchUpdate(e)}async updateNext(t,e,r,i,o){const a=await this.getNextMatches(t,e,r,i,o);if(a.length===0)return;const u=g.getMatchResult(t),d=r.settings.skipFirstRound&&e==="winner_bracket"?i+1:i;u?await this.applyToNextMatches(g.setNextOpponent,t,e,d,o,a,u):await this.applyToNextMatches(g.resetNextOpponent,t,e,d,o,a)}async applyToNextMatches(t,e,r,i,o,a,u){if(r==="final_group"){if(!a[0])throw Error("First next match is null.");t(a[0],"opponent1",e,"opponent1"),t(a[0],"opponent2",e,"opponent2"),await this.applyMatchUpdate(a[0]);return}const d=g.getNextSide(e.number,i,o,r);if(a[0]&&(t(a[0],d,e,u),await this.propagateByeWinners(a[0])),a.length===2){if(!a[1])throw Error("Second next match is null.");if(r==="single_bracket")t(a[1],d,e,u&&g.getOtherSide(u)),await this.applyMatchUpdate(a[1]);else{const c=g.getNextSideLoserBracket(e.number,a[1],i);t(a[1],c,e,u&&g.getOtherSide(u)),await this.propagateByeWinners(a[1])}}}async propagateByeWinners(t){g.setMatchResults(t,t,!1),await this.applyMatchUpdate(t),g.hasBye(t)&&await this.updateRelatedMatches(t,!0,!0)}}D.BaseUpdater=Z;Object.defineProperty(x,"__esModule",{value:!0});x.Update=void 0;const Ve=N,Xe=v,Je=D,E=s;class Qe extends Je.BaseUpdater{async match(t){if(t.id===void 0)throw Error("No match id given.");const e=await this.storage.select("match",t.id);if(!e)throw Error("Match not found.");await this.updateMatch(e,t)}async matchGame(t){const e=await this.findMatchGame(t);await this.updateMatchGame(e,t)}async ordering(t,e){const r=await this.storage.select("stage",t);if(!r)throw Error("Stage not found.");E.ensureNotRoundRobin(r);const i=await this.getOrderedRounds(r);if(e.length!==i.length)throw Error("The count of seed orderings is incorrect.");for(let o=0;o<i.length;o++)await this.updateRoundOrdering(i[o],e[o])}async roundOrdering(t,e){const r=await this.storage.select("round",t);if(!r)throw Error("This round does not exist.");const i=await this.storage.select("stage",r.stage_id);if(!i)throw Error("Stage not found.");E.ensureNotRoundRobin(i),await this.updateRoundOrdering(r,e)}async matchChildCount(t,e,r){switch(t){case"stage":await this.updateStageMatchChildCount(e,r);break;case"group":await this.updateGroupMatchChildCount(e,r);break;case"round":await this.updateRoundMatchChildCount(e,r);break;case"match":const i=await this.storage.select("match",e);if(!i)throw Error("Match not found.");await this.adjustMatchChildGames(i,r);break;default:throw Error("Unknown child count level.")}}async seeding(t,e){await this.updateSeeding(t,e)}async confirmSeeding(t){await this.confirmCurrentSeeding(t)}async updateRoundOrdering(t,e){const r=await this.storage.select("match",{round_id:t.id});if(!r)throw Error("This round has no match.");if(r.some(p=>p.status>Ve.Status.Ready))throw Error("At least one match has started or is completed.");const i=await this.storage.select("stage",t.stage_id);if(!i)throw Error("Stage not found.");if(i.settings.size===void 0)throw Error("Undefined stage size.");const o=await this.storage.select("group",t.group_id);if(!o)throw Error("Group not found.");const a=E.isLoserBracket(i.type,o.number),u=E.getLowerBracketRoundCount(i.settings.size),d=E.getSeeds(a,t.number,u,r.length),c=Xe.ordering[e](d);await this.applyRoundOrdering(t.number,r,c)}async updateStageMatchChildCount(t,e){if(!await this.storage.update("match",{stage_id:t},{child_count:e}))throw Error("Could not update the match.");const r=await this.storage.select("match",{stage_id:t});if(!r)throw Error("This stage has no match.");for(const i of r)await this.adjustMatchChildGames(i,e)}async updateGroupMatchChildCount(t,e){if(!await this.storage.update("match",{group_id:t},{child_count:e}))throw Error("Could not update the match.");const r=await this.storage.select("match",{group_id:t});if(!r)throw Error("This group has no match.");for(const i of r)await this.adjustMatchChildGames(i,e)}async updateRoundMatchChildCount(t,e){if(!await this.storage.update("match",{round_id:t},{child_count:e}))throw Error("Could not update the match.");const r=await this.storage.select("match",{round_id:t});if(!r)throw Error("This round has no match.");for(const i of r)await this.adjustMatchChildGames(i,e)}async applyRoundOrdering(t,e,r){for(const i of e){const o={...i};if(o.opponent1=E.findPosition(e,r.shift()),t===1&&(o.opponent2=E.findPosition(e,r.shift())),!await this.storage.update("match",o.id,o))throw Error("Could not update the match.")}}async adjustMatchChildGames(t,e){const r=await this.storage.select("match_game",{parent_id:t.id});let i=r?r.length:0;for(;i<e;){if(await this.storage.insert("match_game",{number:i+1,stage_id:t.stage_id,parent_id:t.id,status:t.status,opponent1:{id:null},opponent2:{id:null}})===-1)throw Error("Could not adjust the match games when inserting.");i++}for(;i>e;){if(!await this.storage.delete("match_game",{parent_id:t.id,number:i}))throw Error("Could not adjust the match games when deleting.");i--}if(!await this.storage.update("match",t.id,{...t,child_count:e}))throw Error("Could not update the match.")}}x.Update=Qe;var A={};Object.defineProperty(A,"__esModule",{value:!0});A.Delete=void 0;class He{constructor(t){this.storage=t}async stage(t){if(!await this.storage.delete("match_game",{stage_id:t}))throw Error("Could not delete match games.");if(!await this.storage.delete("match",{stage_id:t}))throw Error("Could not delete matches.");if(!await this.storage.delete("round",{stage_id:t}))throw Error("Could not delete rounds.");if(!await this.storage.delete("group",{stage_id:t}))throw Error("Could not delete groups.");if(!await this.storage.delete("stage",{id:t}))throw Error("Could not delete stages.")}}A.Delete=He;var $={};Object.defineProperty($,"__esModule",{value:!0});$.Find=void 0;const Ke=k,Y=s;class Ze extends Ke.BaseGetter{async upperBracket(t){const e=await this.storage.select("stage",t);if(!e)throw Error("Stage not found.");switch(e.type){case"round_robin":throw Error("Round-robin stages do not have an upper bracket.");case"single_elimination":case"double_elimination":return this.getUpperBracket(t);default:throw Error("Unknown stage type.")}}async loserBracket(t){const e=await this.storage.select("stage",t);if(!e)throw Error("Stage not found.");switch(e.type){case"round_robin":throw Error("Round-robin stages do not have a loser bracket.");case"single_elimination":throw Error("Single elimination stages do not have a loser bracket.");case"double_elimination":const r=await this.getLoserBracket(t);if(!r)throw Error("Loser bracket not found.");return r;default:throw Error("Unknown stage type.")}}async previousMatches(t){const e=await this.storage.select("match",t);if(!e)throw Error("Match not found.");const r=await this.storage.select("stage",e.stage_id);if(!r)throw Error("Stage not found.");const i=await this.storage.select("group",e.group_id);if(!i)throw Error("Group not found.");const o=await this.storage.select("round",e.round_id);if(!o)throw Error("Round not found.");const a=Y.getMatchLocation(r.type,i.number);return this.getPreviousMatches(e,a,r,o.number)}async nextMatches(t){const e=await this.storage.select("match",t);if(!e)throw Error("Match not found.");const r=await this.storage.select("stage",e.stage_id);if(!r)throw Error("Stage not found.");const i=await this.storage.select("group",e.group_id);if(!i)throw Error("Group not found.");const{roundNumber:o,roundCount:a}=await this.getRoundPositionalInfo(e.round_id),u=Y.getMatchLocation(r.type,i.number),d=await this.getNextMatches(e,u,r,o,a);return Y.getNonNull(d)}async match(t,e,r){return this.findMatch(t,e,r)}async matchGame(t){return this.findMatchGame(t)}}$.Find=Ze;var q={};Object.defineProperty(q,"__esModule",{value:!0});q.Reset=void 0;const tn=N,en=D,R=s;class nn extends en.BaseUpdater{async matchResults(t){const e=await this.storage.select("match",t);if(!e)throw Error("Match not found.");if(!R.isMatchForfeitCompleted(e)&&e.child_count>0)throw Error("The parent match is controlled by its child games and its result cannot be reset.");const r=await this.storage.select("stage",e.stage_id);if(!r)throw Error("Stage not found.");const i=await this.storage.select("group",e.group_id);if(!i)throw Error("Group not found.");const{roundNumber:o,roundCount:a}=await this.getRoundPositionalInfo(e.round_id),u=R.getMatchLocation(r.type,i.number);if((await this.getNextMatches(e,u,r,o,a)).some(c=>c&&c.status>=tn.Status.Running&&!R.isMatchByeCompleted(c)))throw Error("The match is locked.");R.resetMatchResults(e),await this.applyMatchUpdate(e),R.isRoundRobin(r)||await this.updateRelatedMatches(e,!0,!0)}async matchGameResults(t){const e=await this.storage.select("match_game",t);if(!e)throw Error("Match game not found.");const r=await this.storage.select("stage",e.stage_id);if(!r)throw Error("Stage not found.");const i=R.isRoundRobin(r);if(R.resetMatchResults(e),!await this.storage.update("match_game",e.id,e))throw Error("Could not update the match game.");await this.updateParentMatch(e.parent_id,i)}async seeding(t){await this.updateSeeding(t,null)}}q.Reset=nn;Object.defineProperty(I,"__esModule",{value:!0});I.BracketsManager=void 0;const rn=B,on=T,sn=x,an=A,un=$,dn=q,cn=s;class ln{constructor(t){const e=t;e.selectFirst=async(r,i)=>{const o=await this.storage.select(r,i);return!o||o.length===0?null:o[0]},e.selectLast=async(r,i)=>{const o=await this.storage.select(r,i);return!o||o.length===0?null:o[o.length-1]},this.storage=e,this.get=new on.Get(this.storage),this.update=new sn.Update(this.storage),this.delete=new an.Delete(this.storage),this.find=new un.Find(this.storage),this.reset=new dn.Reset(this.storage)}async create(t){await rn.create.call(this,t)}async import(t,e=!1){if(e&&(t=cn.normalizeIds(t)),!await this.storage.delete("participant"))throw Error("Could not empty the participant table.");if(!await this.storage.insert("participant",t.participant))throw Error("Could not import participants.");if(!await this.storage.delete("stage"))throw Error("Could not empty the stage table.");if(!await this.storage.insert("stage",t.stage))throw Error("Could not import stages.");if(!await this.storage.delete("group"))throw Error("Could not empty the group table.");if(!await this.storage.insert("group",t.group))throw Error("Could not import groups.");if(!await this.storage.delete("round"))throw Error("Could not empty the round table.");if(!await this.storage.insert("round",t.round))throw Error("Could not import rounds.");if(!await this.storage.delete("match"))throw Error("Could not empty the match table.");if(!await this.storage.insert("match",t.match))throw Error("Could not import matches.");if(!await this.storage.delete("match_game"))throw Error("Could not empty the match_game table.");if(!await this.storage.insert("match_game",t.match_game))throw Error("Could not import match games.")}async export(){const t=await this.storage.select("participant");if(!t)throw Error("Error getting participants.");const e=await this.storage.select("stage");if(!e)throw Error("Error getting stages.");const r=await this.storage.select("group");if(!r)throw Error("Error getting groups.");const i=await this.storage.select("round");if(!i)throw Error("Error getting rounds.");const o=await this.storage.select("match");if(!o)throw Error("Error getting matches.");const a=await this.get.matchGames(o);return{participant:t,stage:e,group:r,round:i,match:o,match_game:a}}}I.BracketsManager=ln;(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.helpers=n.BracketsManager=void 0;const t=I;Object.defineProperty(n,"BracketsManager",{enumerable:!0,get:function(){return t.BracketsManager}});const e=s;n.helpers={getWinner:e.getWinner,getLoser:e.getLoser,getMatchResult:e.getMatchResult,isMatchStarted:e.isMatchStarted,isMatchCompleted:e.isMatchCompleted,isMatchForfeitCompleted:e.isMatchForfeitCompleted,isMatchResultCompleted:e.isMatchResultCompleted,isMatchDrawCompleted:e.isMatchDrawCompleted,isMatchWinCompleted:e.isMatchWinCompleted,isMatchByeCompleted:e.isMatchByeCompleted,isMatchUpdateLocked:e.isMatchUpdateLocked,isMatchParticipantLocked:e.isMatchParticipantLocked,hasBye:e.hasBye,getUpperBracketRoundCount:e.getUpperBracketRoundCount,getRoundPairCount:e.getRoundPairCount,getLoserRoundMatchCount:e.getLoserRoundMatchCount,getLoserRoundLoserCount:e.getLoserRoundLoserCount,getLowerBracketRoundCount:e.getLowerBracketRoundCount,getNearestPowerOfTwo:e.getNearestPowerOfTwo,minScoreToWinBestOfX:e.minScoreToWinBestOfX,isRoundRobin:e.isRoundRobin,isWinnerBracket:e.isWinnerBracket,isLoserBracket:e.isLoserBracket,isFinalGroup:e.isFinalGroup,getMatchLocation:e.getMatchLocation}})(X);const gn=xt(X),hn=It({__proto__:null,default:gn},[X]);export{hn as i};
