class d{constructor(){this.data={stage:[],group:[],round:[],match:[],match_game:[],participant:[]}}nextId(r){const e=this.data[r]||[];let t=-1;for(const s of e)typeof s.id=="number"&&(t=Math.max(t,s.id));return t+1}async insert(r,e){if(Array.isArray(e)){for(const n of e)await this.insert(r,n);return!0}const t=this.nextId(r),s={...e,id:t};return this.data[r]=(this.data[r]||[]).concat([s]),t}async select(r,e){const t=this.data[r]||[];if(typeof e>"u")return t.slice();if(typeof e=="number")return t.find(n=>n.id===e)||null;const s=e;return t.filter(n=>{for(const i of Object.keys(s))if(n[i]!==s[i])return!1;return!0})}async update(r,e,t){const s=this.data[r]||[];if(typeof e=="number"){const a=s.findIndex(c=>c.id===e);return a===-1?!1:(s[a]=t,this.data[r]=s,!0)}const n=e;let i=!1;for(let a=0;a<s.length;a++){const c=s[a];let o=!0;for(const f of Object.keys(n))if(c[f]!==n[f]){o=!1;break}o&&(this.data[r][a]={...c,...t},i=!0)}return i}async delete(r,e){if(!e)return this.data[r]=[],!0;const t=(this.data[r]||[]).length;return this.data[r]=(this.data[r]||[]).filter(s=>{for(const n of Object.keys(e))if(s[n]!==e[n])return!0;return!1}),(this.data[r]||[]).length<t}async selectFirst(r,e){const t=await this.select(r,e);return Array.isArray(t)?t[0]||null:t}async selectLast(r,e){const t=await this.select(r,e);return Array.isArray(t)?t[t.length-1]||null:t}}export{d as InMemoryStorage,d as default};
